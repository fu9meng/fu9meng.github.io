<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>斜阳的博客</title>
  
  <subtitle>浮生若梦，人生几何</subtitle>
  <link href="http://fu9meng.github.io/atom.xml" rel="self"/>
  
  <link href="http://fu9meng.github.io/"/>
  <updated>2022-05-20T05:21:15.412Z</updated>
  <id>http://fu9meng.github.io/</id>
  
  <author>
    <name>斜阳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于CNN的西储数据故障诊断</title>
    <link href="http://fu9meng.github.io/2022/05/20/test/cnn/"/>
    <id>http://fu9meng.github.io/2022/05/20/test/cnn/</id>
    <published>2022-05-20T05:21:40.000Z</published>
    <updated>2022-05-20T05:21:15.412Z</updated>
    
    <content type="html"><![CDATA[<p>这个主要是我的故障诊断大作业，要求是使用一种机器学习的方法完场对凯斯西储轴承数据库的智能故障诊断。我使用的是助教建议的方案，使用 Python 语言、 PyTorch 框架，运用卷积神经网络对凯斯西储大学的轴承数据进行故障诊断。</p><h1 id="需要的库"><a href="#需要的库" class="headerlink" title="需要的库"></a>需要的库</h1><p>本次是使用 cpu 的 PyTorch ，如需使用 GPU ，请自行添加。下面是用到的库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> maxabs_scale</span><br></pre></td></tr></table></figure><h1 id="创建数据集"><a href="#创建数据集" class="headerlink" title="创建数据集"></a>创建数据集</h1><p>本次使用凯斯西储大学轴承数据、采样频率为12kHz 的驱动端故障数据、选用1797rpm 转速（即电机载荷为1马力）下的故障直径为0.1778mm 的滚动体故障以及三组不同位置的外圈故障，三组不同故障直径的内圈故障以及正常数据，共八组数据。其中80%用于训练，20%用于测试。同时选用转速为选用1750rpm 转速（即电机载荷为2马力）的数据进行其泛化能力的验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1马力载荷下，采样频率为12kHz的驱动端故障数据</span></span><br><span class="line">NC1 = <span class="string">r&quot;E:\Data\CWRU\NormalBaseline\1772\Normal.mat&quot;</span> <span class="comment"># 正常信号</span></span><br><span class="line">IF1_1 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1772\0.007-InnerRace.mat&quot;</span> <span class="comment"># 内圈故障故障直径0.1778mm</span></span><br><span class="line">IF2_1 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1772\0.014-InnerRace.mat&quot;</span> <span class="comment"># 内圈故障故障直径0.3556mm</span></span><br><span class="line">IF3_1 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1772\0.021-InnerRace.mat&quot;</span> <span class="comment"># 内圈故障故障直径0.5334mm</span></span><br><span class="line">OF3_1 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1772\0.007-OuterRace3.mat&quot;</span> <span class="comment"># 外圈3点钟方向故障</span></span><br><span class="line">OF6_1 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1772\0.007-OuterRace6.mat&quot;</span> <span class="comment"># 外圈6点钟方向故障</span></span><br><span class="line">OF12_1 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1772\0.007-OuterRace12.mat&quot;</span> <span class="comment"># 外圈12点钟方向故障</span></span><br><span class="line">BF1 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1772\0.007-Ball.mat&quot;</span> <span class="comment"># 滚子故障</span></span><br><span class="line"></span><br><span class="line">paths1 = [NC1, IF1_1, IF2_1, IF3_1, OF3_1, OF6_1, OF12_1, BF1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2马力载荷下的数据</span></span><br><span class="line">NC2 = <span class="string">r&quot;E:\Data\CWRU\NormalBaseline\1750\Normal.mat&quot;</span></span><br><span class="line">IF1_2 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1750\0.007-InnerRace.mat&quot;</span></span><br><span class="line">IF2_2 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1750\0.014-InnerRace.mat&quot;</span></span><br><span class="line">IF3_2 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1750\0.021-InnerRace.mat&quot;</span></span><br><span class="line">OF3_2 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1750\0.007-OuterRace3.mat&quot;</span></span><br><span class="line">OF6_2 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1750\0.007-OuterRace6.mat&quot;</span></span><br><span class="line">OF12_2 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1750\0.007-OuterRace12.mat&quot;</span></span><br><span class="line">BF2 = <span class="string">r&quot;E:\Data\CWRU\12DriveEndFault\1750\0.007-Ball.mat&quot;</span></span><br><span class="line"></span><br><span class="line">paths2 = [NC2, IF1_2, IF2_2, IF3_2, OF3_2, OF6_2, OF12_2, BF2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据集</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_data</span>(<span class="params">paths, num, length</span>):</span><br><span class="line">data = np.zeros([<span class="number">8</span>, num, length], dtype=np.float32) <span class="comment"># 创建一个空的张量8*100*1024</span></span><br><span class="line">  <span class="comment"># 写入数据，并将其分为100*1024（100份，每份1024个）</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">    data[i] = load_mat_data(paths[i], item_name=<span class="string">&#x27;DE_time&#x27;</span>,</span><br><span class="line">              num_points=num * length).reshape([num, length])</span><br><span class="line">label = np.arange(<span class="built_in">len</span>(paths)).reshape([<span class="built_in">len</span>(paths), <span class="number">1</span>])</span><br><span class="line">    label = np.tile(label, (<span class="number">1</span>, num)) <span class="comment"># 确定标签</span></span><br><span class="line">    <span class="keyword">return</span> data.reshape(-<span class="number">1</span>, length), label.reshape(-<span class="number">1</span>) <span class="comment"># 只返回一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从.mat中写入数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_mat_data</span>(<span class="params">path, item_name=<span class="string">&#x27;DE_time&#x27;</span>, num_points=<span class="number">1024</span> * <span class="number">100</span></span>):</span><br><span class="line">  mat_data = sio.loadmat(path) <span class="comment"># 加载数据</span></span><br><span class="line">  name_new = []</span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">list</span>(mat_data.keys()):</span><br><span class="line">  <span class="keyword">if</span> item_name <span class="keyword">in</span> n:</span><br><span class="line">name_new.append(n)</span><br><span class="line">data = mat_data[name_new[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">return</span> data[:num_points]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从dataset组织训练数</span></span><br><span class="line"><span class="comment"># 定义数据集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CWRU_DATA</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, paths, data_num, data_len=<span class="number">1024</span></span>):</span><br><span class="line">        self.data, self.label = prepare_data(paths, num=data_num, length=data_len)  <span class="comment"># (8, n, 1024)</span></span><br><span class="line">        <span class="comment"># 得到数据和标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据预处理，调整数据格式，都变成np.float32</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data_preprocess</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x.astype(np.float32)  <span class="comment"># 类型转换</span></span><br><span class="line">        x = maxabs_scale(x)  <span class="comment">#</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        data, label = self.data[item], self.label[item]  <span class="comment"># (1024, ), (1, )</span></span><br><span class="line">        data = self.data_preprocess(data)</span><br><span class="line">        <span class="keyword">return</span> data, label</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义迭代器并将数据集打乱</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_dataloader</span>(<span class="params">dataset, shuffle, batch_size</span>):</span><br><span class="line"><span class="keyword">return</span> DataLoader(dataset, batch_size, shuffle=shuffle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据初始化</span></span><br><span class="line">dataset1 = CWRU_DATA(paths1, <span class="number">100</span>) <span class="comment"># 1马力载荷</span></span><br><span class="line">dataloader1 = build_dataloader(dataset1, shuffle=<span class="literal">True</span>, batch_size=<span class="number">32</span>)</span><br><span class="line">dataset2 = CWRU_DATA(paths2, <span class="number">20</span>) <span class="comment"># 2马力载荷</span></span><br><span class="line">dataloader2 = build_dataloader(dataset2, shuffle=<span class="literal">True</span>, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure><h1 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CNN 基本模块   in输入数据的深度，out 输出数据的深度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv_block</span>(<span class="params">in_channels, out_channels</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.Conv1d(in_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># 卷积层，卷积核为3，进行1个像素的零填充</span></span><br><span class="line">        nn.BatchNorm1d(out_channels),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.MaxPool1d(kernel_size=<span class="number">2</span>),  <span class="comment"># 池化层，卷积核为2</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_chn=<span class="number">1</span>, hidden_chn=<span class="number">64</span>, block_num=<span class="number">4</span>, sample_len=<span class="number">1024</span>, classes=<span class="number">8</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        conv1 = conv_block(in_chn, hidden_chn)  <span class="comment"># 首次输入，输入深度为1，输出为64</span></span><br><span class="line">        conv1_more = [conv_block(hidden_chn, hidden_chn) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(block_num - <span class="number">1</span>)]  <span class="comment"># 后三次，输入输出均为64</span></span><br><span class="line">        self.features = nn.Sequential(conv1, *conv1_more)  <span class="comment"># 得到表单，(None, 64, 1024/2^4)</span></span><br><span class="line"></span><br><span class="line">        flatten_size = <span class="built_in">int</span>(sample_len / (<span class="number">2</span> ** block_num) * hidden_chn)  <span class="comment"># 设置线性尺寸1024/</span></span><br><span class="line">        self.classifier = nn.Sequential(nn.Flatten(), nn.Linear(flatten_size, classes))  <span class="comment"># 分类器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        feat = self.features(x)</span><br><span class="line">        out = self.classifier(feat)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">model = net()</span><br><span class="line"><span class="comment"># 学习率lr lr=1e-3</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-3</span>)  <span class="comment"># 优化函数</span></span><br><span class="line">criterion = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;mean&#x27;</span>)  <span class="comment"># 定义损失函数</span></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">EPOCH = <span class="number">5</span>  <span class="comment"># 训练次数</span></span><br><span class="line">loss_y = []  <span class="comment"># 记录损失</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH):</span><br><span class="line">    <span class="keyword">for</span> i, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader1):</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">20</span>:</span><br><span class="line">            data, label = batch</span><br><span class="line">            data, label = data.<span class="built_in">float</span>().unsqueeze(<span class="number">1</span>), label.long()</span><br><span class="line">            predict_label = model(data)  <span class="comment"># 预测的标签</span></span><br><span class="line">            loss = criterion(predict_label, label)  <span class="comment"># 对比标签计算损失</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 梯度计算,权重更新</span></span><br><span class="line">            loss.backward()  <span class="comment"># 得到损失函数</span></span><br><span class="line">            optimizer.step()</span><br><span class="line">            optimizer.zero_grad()  <span class="comment"># 归零梯度</span></span><br><span class="line"></span><br><span class="line">            loss_y.append(loss.detach().item())</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_y)+<span class="number">1</span>))</span><br><span class="line">plt.plot(x, loss_y, <span class="string">&#x27;r.--&#x27;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;train_fre&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, EPOCH+<span class="number">1</span>):</span><br><span class="line">    plt.text(<span class="number">20</span>*i, loss_y[<span class="number">20</span>*i-<span class="number">1</span>], <span class="built_in">round</span>(loss_y[<span class="number">20</span>*i-<span class="number">1</span>], <span class="number">4</span>), va=<span class="string">&#x27;top&#x27;</span>, ha=<span class="string">&#x27;right&#x27;</span>, fontsize=<span class="number">12</span>)  <span class="comment"># 标相应数字</span></span><br><span class="line">plt.title(<span class="string">&#x27;loss&#x27;</span>)  <span class="comment"># 设置图片标题</span></span><br><span class="line">plt.savefig(os.path.join(<span class="string">&#x27;./&#x27;</span>, <span class="string">&#x27;loss.png&#x27;</span>), dpi=<span class="number">500</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure><h1 id="混淆矩阵可视化"><a href="#混淆矩阵可视化" class="headerlink" title="混淆矩阵可视化"></a>混淆矩阵可视化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据可视化，混淆矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_confMat</span>(<span class="params">confusion_mat, classes_name, set_name, out_dir</span>):</span><br><span class="line">    <span class="comment"># confusion_mat: nd-array classes_name: list,各类别名称 set_name: str out_dir: 输出的文件夹</span></span><br><span class="line">    <span class="comment"># 归一化</span></span><br><span class="line">    confusion_mat_N = confusion_mat.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes_name)):</span><br><span class="line">        confusion_mat_N[i, :] = confusion_mat[i, :] / confusion_mat[i, :].<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取颜色</span></span><br><span class="line">    cmap = plt.cm.get_cmap(<span class="string">&#x27;Greys&#x27;</span>)</span><br><span class="line">    plt.imshow(confusion_mat_N, cmap=cmap)</span><br><span class="line">    plt.colorbar()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置文字</span></span><br><span class="line">    xlocations = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(classes_name)))</span><br><span class="line">    plt.xticks(xlocations, classes_name, rotation=<span class="number">60</span>)</span><br><span class="line">    plt.yticks(xlocations, classes_name)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Predict label&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;True label&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Confusion_Matrix_&#x27;</span> + set_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印数字</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(confusion_mat_N.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(confusion_mat_N.shape[<span class="number">1</span>]):</span><br><span class="line">            plt.text(x=j, y=i, s=<span class="built_in">int</span>(confusion_mat[i, j]), va=<span class="string">&#x27;center&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">    <span class="comment"># 保存</span></span><br><span class="line">    plt.savefig(os.path.join(out_dir, <span class="string">&#x27;Confusion_Matrix_&#x27;</span> + set_name + <span class="string">&#x27;.png&#x27;</span>), dpi=<span class="number">500</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">    plt.close()</span><br></pre></td></tr></table></figure><h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">dataloaders, a, b</span>):</span><br><span class="line">    test_labels = torch.IntTensor()</span><br><span class="line">    predictions = torch.IntTensor()  <span class="comment"># 生成int型空张量</span></span><br><span class="line">    <span class="keyword">for</span> i, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloaders):</span><br><span class="line">        <span class="keyword">if</span> i &gt;= a:</span><br><span class="line">            test_data, test_label = batch</span><br><span class="line">            test_data, test_label = test_data.<span class="built_in">float</span>().unsqueeze(<span class="number">1</span>), test_label.long()</span><br><span class="line">            test_labels = torch.cat([test_labels, test_label], <span class="number">0</span>)  <span class="comment"># 拼装张量</span></span><br><span class="line">            prediction = model(test_data)</span><br><span class="line">            prediction = prediction.argmax(dim=-<span class="number">1</span>).view(test_label.shape)</span><br><span class="line">            predictions = torch.cat([predictions, prediction], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    accuracy = (predictions == test_labels).<span class="built_in">sum</span>().<span class="built_in">float</span>() / test_labels.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;载荷为<span class="subst">&#123;b&#125;</span>下的正确率：<span class="subst">&#123;accuracy * <span class="number">100</span>&#125;</span>%&#x27;</span>)</span><br><span class="line">    <span class="comment"># 混淆矩阵</span></span><br><span class="line">    cls_num = <span class="number">8</span></span><br><span class="line">    conf_mat = np.zeros([cls_num, cls_num])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_labels)):</span><br><span class="line">        true_i = np.array(test_labels[i])</span><br><span class="line">        pre_i = np.array(predictions[i])</span><br><span class="line">        conf_mat[true_i, pre_i] += <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    show_confMat(conf_mat, [<span class="string">&quot;NC&quot;</span>, <span class="string">&quot;IF1&quot;</span>, <span class="string">&quot;IF2&quot;</span>, <span class="string">&quot;IF3&quot;</span>, <span class="string">&quot;OF3&quot;</span>, <span class="string">&quot;OF6&quot;</span>, <span class="string">&quot;OF12&quot;</span>, <span class="string">&quot;BF&quot;</span>], <span class="string">f&quot;test<span class="subst">&#123;b&#125;</span>&quot;</span>, <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(dataloader1, <span class="number">20</span>, <span class="number">1</span>)</span><br><span class="line">test(dataloader2, <span class="number">0</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>注：本文部分代码参考<a href="http://t.csdn.cn/qBjpa">基于简单CNN的西楚数据集智能诊断</a>。如有侵权，联系删除。</p>]]></content>
    
    
    <summary type="html">使用 PyTorch 框架，针对凯斯西储数据集进行故障诊断</summary>
    
    
    
    <category term="课程大作业" scheme="http://fu9meng.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="PyTorch" scheme="http://fu9meng.github.io/tags/PyTorch/"/>
    
    <category term="故障诊断" scheme="http://fu9meng.github.io/tags/%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/"/>
    
    <category term="凯斯西储数据库" scheme="http://fu9meng.github.io/tags/%E5%87%AF%E6%96%AF%E8%A5%BF%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="CNN" scheme="http://fu9meng.github.io/tags/CNN/"/>
    
  </entry>
  
</feed>
